<?php

use Illuminate\Database\Seeder;

class GuidesTableSeeder extends Seeder {

    public function run() {
        DB::table('guides')->delete();

        DB::insert('insert into guides (writerId , title, content) VALUE (?, ?, ?)',
                    [1, '1. The way of the program',
                        '<p>The goal of this book is to teach you to think like a computer scientist. This way of thinking&nbsp;combines some of the best features of mathematics, engineering, and natural science. Like mathematicians,&nbsp;computer scientists use formal languages to denote ideas (specifically computations).<br />Like engineers, they design things, assembling components into systems and evaluating tradeoffs&nbsp;among alternatives. Like scientists, they observe the behavior of complex systems, form hypotheses,&nbsp;and test predictions.<br />The single most important skill for a computer scientist is <strong>problem solving</strong>. Problem solving&nbsp;means the ability to formulate problems, think creatively about solutions, and express a solution<br />clearly and accurately. As it turns out, the process of learning to program is an excellent opportunity&nbsp;to practice problem-solving skills. That&rsquo;s why this chapter is called, The way of the program.<br />On one level, you will be learning to program, a useful skill by itself. On another level, you will&nbsp;use programming as a means to an end. As we go along, that end will become clearer.</p>
                        <h2><br />1.1 The Python programming language</h2>
                        <p><br />The programming language you will be learning is Python. Python is an example of a <strong>high-level&nbsp;</strong><strong>language</strong>; other high-level languages you might have heard of are C++, PHP, and Java.<br />As you might infer from the name high-level language, there are also <strong>low-level languages</strong>, sometimes&nbsp;referred to as machine languages or assembly languages. Loosely speaking, computers can&nbsp;only execute programs written in low-level languages. Thus, programs written in a high-level language&nbsp;have to be processed before they can run. This extra processing takes some time, which is a&nbsp;small disadvantage of high-level languages.<br />But the advantages are enormous. First, it is much easier to program in a high-level language.&nbsp;Programs written in a high-level language take less time to write, they are shorter and easier to&nbsp;read, and they are more likely to be correct. Second, high-level languages are <strong>portable</strong>, meaning&nbsp;that they can run on different kinds of computers with few or no modifications. Low-level programs&nbsp;can run on only one kind of computer and have to be rewritten to run on another.<br />Due to these advantages, almost all programs are written in high-level languages. Low-level languages&nbsp;are used only for a few specialized applications.<br />Two kinds of programs process high-level languages into low-level languages: <strong>interpreters</strong> and&nbsp;<strong>compilers</strong>. An interpreter reads a high-level program and executes it, meaning that it does what the&nbsp;program says. It processes the program a little at a time, alternately reading lines and performing&nbsp;computations.</p>
                        <p><img src="http://www.greenteapress.com/thinkpython/html/thinkpython001.png" alt="" width="332" height="79" /></p>
                        <p>A compiler reads the program and translates it completely before the program starts running. In&nbsp;this case, the high-level program is called the <strong>source code</strong>, and the translated program is called the<br /><strong>object code</strong> or the <strong>executable</strong>. Once a program is compiled, you can execute it repeatedly without&nbsp;further translation.</p>
                        <p><img src="http://www.greenteapress.com/thinkpython/html/thinkpython002.png" alt="" width="484" height="79" /><br />Many modern languages use both processes. They are first compiled into a lower level language,&nbsp;called <strong>byte code</strong>, and then interpreted by a program called a <strong>virtual machine</strong>. Python uses both&nbsp;processes, but because of the way programmers interact with it, it is usually considered an interpreted&nbsp;language.</p>
                        <p><br />There are two ways to use the Python interpreter: <em>shell mode</em> and <em>script mode</em>. In shell mode, you<br />type Python expressions into the <strong>Python shell</strong>, and the interpreter immediately shows the result:</p>
                        <p><code>$ python3</code><br /><code>Python 3.2 (r32:88445, Mar 25 2011, 19:28:28)</code><br /><code>[GCC 4.5.2] on linux2</code><br /><code>Type "help", "copyright", "credits" or "license" for more information.</code><br /><code>&gt;&gt;&gt; 2 + 2</code><br /><code>4</code><br /><code>&gt;&gt;&gt;</code></p>
                        <p><br />The &gt;&gt;&gt; is called the <strong>Python prompt</strong>. The interpreter uses the prompt to indicate that it is ready&nbsp;for instructions. We typed 2 + 2, and the interpreter evaluated our expression, and replied 4, and<br />on the next line it gave a new prompt, indicating that it is ready for more input.<br />Alternatively, you can write a program in a file and use the interpreter to execute the contents of&nbsp;the file. Such a file is called a <strong>script</strong>. For example, we used a text editor to create a file named&nbsp;firstprogram.py with the following contents:</p>
                        <p><br /><code>print("My first program adds two numbers, 2 and 3:")</code><br /><code>print(2 + 3)</code></p>
                        <p><br />By convention, files that contain Python programs have names that end with <code>.py</code> . Following this&nbsp;convention will help your operating system and other programs identify a file as containing python&nbsp;code.</p>
                        <p><br /><code>$ python firstprogram.py</code><br /><code>My first program adds two numbers, 2 and 3:</code><br /><code>5</code></p>
                        <p><br />These examples show Python being run from a Unix command line. In other development environments,&nbsp;the details of executing programs may differ. Also, most programs are more interesting&nbsp;than this one.<br />The examples in this book use both the Python interpreter and scripts. You will be able to tell&nbsp;which is intended since shell mode examples will always start with the Python prompt.<br />Working directly in the interpreter is convenient for testing short bits of code because you get&nbsp;immediate feedback. Think of it as scratch paper used to help you work out problems. Anything&nbsp;longer than a few lines should be put into a script.</p>
                        <h2><br />1.2 What is a program?</h2>
                        <p><br />A <strong>program</strong> is a sequence of instructions that specifies how to perform a computation. The computation&nbsp;might be something mathematical, such as solving a system of equations or finding the&nbsp;roots of a polynomial, but it can also be a symbolic computation, such as searching and replacing&nbsp;text in a document or (strangely enough) compiling a program.<br />The details look different in different languages, but a few basic instructions appear in just about&nbsp;every language:</p>
                        <p style="padding-left: 30px;"><br /><strong>input</strong> Get data from the keyboard, a file, or some other device.<br /><strong>output</strong> Display data on the screen or send data to a file or other device.<br /><strong>math and logic</strong> Perform basic mathematical operations like addition, and multiplication, and logical&nbsp;operations like and, or, and not.<br /><strong>conditional execution</strong> Check for certain conditions and execute the appropriate sequence of statements.<br /><strong>repetition</strong> Perform some action repeatedly, usually with some variation.</p>
                        <p>Believe it or not, that&rsquo;s pretty much all there is to it. Every program you&rsquo;ve ever used, no matter&nbsp;how complicated, is made up of instructions that look more or less like these. Thus, we can describe&nbsp;programming as the process of breaking a large, complex task into smaller and smaller subtasks&nbsp;until the subtasks are simple enough to be performed with sequences of these basic instructions.<br />That may be a little vague, but we will come back to this topic later when we talk about algorithms.</p>
                        <h2><br />1.3 What is debugging?</h2>
                        <p><br />Programming is a complex process, and because it is done by human beings, it often leads to errors.<br />Programming errors are called <strong>bugs</strong> and the process of tracking them down and correcting them is&nbsp;called <strong>debugging</strong>. Some claim that in 1945, a dead moth caused a problem on relay number 70,&nbsp;panel F, of one of the first computers at Harvard, and the term <strong>bug</strong> has remained in use since.<br />Three kinds of errors can occur in a program: <em>syntax errors</em>, <em>runtime errors</em>, and <em>semantic errors</em>. It&nbsp;is useful to distinguish between them in order to track them down more quickly.</p>
                        <h2><br />1.4 Syntax errors</h2>
                        <p>Python can only execute a program if the program is syntactically correct; otherwise, the process&nbsp;fails and returns an error message. <strong>Syntax</strong> refers to the structure of a program and the rules about<br />that structure. For example, in English, a sentence must begin with a capital letter and end with a&nbsp;period. this sentence contains a <strong>syntax error</strong>. So does this one&nbsp;</p>
                        <p>For most readers, a few syntax errors are not a significant problem, which is why we can read the&nbsp;poetry of e. e. cummings without problems. Python is not so forgiving. If there is a single syntax&nbsp;error anywhere in your program, Python will display an error message and quit, and you will not&nbsp;be able to run your program. During the first few weeks of your programming career, you will&nbsp;probably spend a lot of time tracking down syntax errors. As you gain experience, though, you&nbsp;will make fewer errors and find them faster.</p>
                        <h2>1.5 Runtime errors</h2>
                        <p>The second type of error is a runtime error, so called because the error does not appear until you run&nbsp;the program. These errors are also called <strong>exceptions</strong> because they usually indicate that something&nbsp;exceptional (and bad) has happened.<br />Runtime errors are rare in the simple programs you will see in the first few chapters, so it might be&nbsp;a while before you encounter one.</p>
                        <h2><br />1.6 Semantic errors</h2>
                        <p>The third type of error is the <strong>semantic error</strong>. If there is a semantic error in your program, it will&nbsp;run successfully, in the sense that the computer will not generate any error messages, but it will&nbsp;not do the right thing. It will do something else. Specifically, it will do what you told it to do.<br />The problem is that the program you wrote is not the program you wanted to write. The meaning of&nbsp;the program (its semantics) is wrong. Identifying semantic errors can be tricky because it requires&nbsp;you to work backward by looking at the output of the program and trying to figure out what it is&nbsp;doing.</p>
                        <h2><br />1.7 Experimental debugging</h2>
                        <p>One of the most important skills you will acquire is debugging. Although it can be frustrating,&nbsp;debugging is one of the most intellectually rich, challenging, and interesting parts of programming.<br />In some ways, debugging is like detective work. You are confronted with clues, and you have to&nbsp;infer the processes and events that led to the results you see.<br />Debugging is also like an experimental science. Once you have an idea what is going wrong, you&nbsp;modify your program and try again. If your hypothesis was correct, then you can predict the result<br />of the modification, and you take a step closer to a working program. If your hypothesis was&nbsp;wrong, you have to come up with a new one. As Sherlock Holmes pointed out, When you have<br />eliminated the impossible, whatever remains, however improbable, must be the truth. (A. Conan&nbsp;Doyle, <em>The Sign of Four</em>)<br />For some people, programming and debugging are the same thing. That is, programming is the&nbsp;process of gradually debugging a program until it does what you want. The idea is that you should<br />start with a program that does <em>something</em> and make small modifications, debugging them as you&nbsp;go, so that you always have a working program.<br />For example, Linux is an operating system kernel that contains millions of lines of code, but it&nbsp;started out as a simple program Linus Torvalds used to explore the Intel 80386 chip. According<br />to Larry Greenfield, one of Linus&rsquo;s earlier projects was a program that would switch between&nbsp;displaying AAAA and BBBB. This later evolved to Linux (<em>The Linux Users&rsquo; Guide</em> Beta Version&nbsp;1).<br />Later chapters will make more suggestions about debugging and other programming practices.</p>
                        <h2><br />1.8 Formal and natural languages</h2>
                        <p><strong>Natural languages</strong> are the languages that people speak, such as English, Spanish, and French.<br />They were not designed by people (although people try to impose some order on them); they&nbsp;evolved naturally.<br /><strong>Formal languages</strong> are languages that are designed by people for specific applications. For example,&nbsp;the notation that mathematicians use is a formal language that is particularly good at denoting<br />relationships among numbers and symbols. Chemists use a formal language to represent the chemical&nbsp;structure of molecules. And most importantly:<br /><em>Programming languages are formal languages that have been designed to express&nbsp;computations.</em><br />Formal languages tend to have strict rules about syntax. For example, <code>3+3=6</code> is a syntactically&nbsp;correct mathematical statement, but <code>3=+6$</code> is not. H<sub>2</sub>O is a syntactically correct chemical name,<br />but 2Zz is not.<br />Syntax rules come in two flavors, pertaining to <strong>tokens</strong> and structure. Tokens are the basic elements&nbsp;of the language, such as words, numbers, and chemical elements. One of the problems with <code>3=+6$</code><br /><br />is that <code>$</code> is not a legal token in mathematics (at least as far as we know). Similarly, <sub>2</sub>Zz is not legal&nbsp;because there is no element with the abbreviation Zz.<br />The second type of syntax rule pertains to the <strong>structure</strong> of a statement&mdash; that is, the way the&nbsp;tokens are arranged. The statement <code>3=+6$</code> is structurally illegal because you can&rsquo;t place a plus<br />sign immediately after an equal sign. Similarly, molecular formulas have to have subscripts after&nbsp;the element name, not before.<br />When you read a sentence in English or a statement in a formal language, you have to figure out&nbsp;what the structure of the sentence is (although in a natural language you do this subconsciously).<br />This process is called <strong>parsing</strong>.<br />For example, when you hear the sentence, &ldquo;The other shoe fell&rdquo;, you understand that the other&nbsp;shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what&nbsp;it means, or the <strong>semantics</strong> of the sentence. Assuming that you know what a shoe is and what it&nbsp;means to fall, you will understand the general implication of this sentence.<br />Although formal and natural languages have many features in common&mdash;tokens, structure, syntax,&nbsp;and semantics &mdash; there are many differences:</p>
                        <p style="padding-left: 30px;"><strong>ambiguity</strong> Natural languages are full of ambiguity, which people deal with by using contextual&nbsp;clues and other information. Formal languages are designed to be nearly or completely unambiguous,&nbsp;which means that any statement has exactly one meaning, regardless of context.<br /><strong>redundancy</strong> In order to make up for ambiguity and reduce misunderstandings, natural languages&nbsp;employ lots of redundancy. As a result, they are often verbose. Formal languages are less<br />redundant and more concise.<br /><strong>literalness</strong> Formal languages mean exactly what they say. On the other hand, natural languages&nbsp;are full of idiom and metaphor. If someone says, &ldquo;The other shoe fell&rdquo;, there is probably no<br />shoe and nothing falling.</p>
                        <p>People who grow up speaking a natural language&mdash;everyone&mdash;often have a hard time adjusting to&nbsp;formal languages. In some ways, the difference between formal and natural language is like the<br />difference between poetry and prose, but more so:</p>
                        <p style="padding-left: 30px;"><strong>poetry</strong> Words are used for their sounds as well as for their meaning, and the whole poem together&nbsp;creates an effect or emotional response. Ambiguity is not only common but often deliberate.<br /><strong>prose</strong> The literal meaning of words is more important, and the structure contributes more meaning.&nbsp;Prose is more amenable to analysis than poetry but still often ambiguous.<br /><strong>program</strong> The meaning of a computer program is unambiguous and literal, and can be understood&nbsp;entirely by analysis of the tokens and structure.</p>
                        <p>Here are some suggestions for reading programs (and other formal languages). First, remember that formal languages are much more dense than natural languages, so it takes longer to read them.<br />Also, the structure is very important, so it is usually not a good idea to read from top to bottom, left&nbsp;to right. Instead, learn to parse the program in your head, identifying the tokens and interpreting&nbsp;the structure. Finally, the details matter. Little things like spelling errors and bad punctuation,&nbsp;which you can get away with in natural languages, can make a big difference in a formal language.</p>
                        <h2><br />1.9 The first program</h2>
                        <p>Traditionally, the first program written in a new language is called Hello, World! because all it&nbsp;does is display the words, Hello, World! In Python, the script looks like this:<br /><code>print("Hello, World!")</code><br />This is an example of using the print function, which doesn&rsquo;t actually print anything on paper. It&nbsp;displays a value on the screen. In this case, the result is the words&nbsp;</p>
                        <p><code>Hello, World!</code></p>
                        <p>The quotation marks in the program mark the beginning and end of the value; they don&rsquo;t appear in&nbsp;the result.<br />Some people judge the quality of a programming language by the simplicity of the Hello, World!&nbsp;program. By this standard, Python does about as well as possible.</p>
                        <h2><br />1.10 Comments</h2>
                        <p>As programs get bigger and more complicated, they get more difficult to read. Formal languages&nbsp;are dense, and it is often difficult to look at a piece of code and figure out what it is doing, or why.<br />For this reason, it is a good idea to add notes to your programs to explain in natural language what&nbsp;the program is doing.<br />A <strong>comment</strong> in a computer program is text that is intended only for the human reader - it is completely&nbsp;ignored by the interpreter.<br />In Python, the # token starts a comment. The rest of the line is ignored. Here is a new version of&nbsp;Hello, World!.</p>
                        <p><code>#---------------------------------------------------</code><br /><code># This demo program shows off how elegant Python is!</code><br /><code># Written by Joe Soap, December 2010.</code><br /><code># Anyone may freely copy or modify this program.</code><br /><code>#---------------------------------------------------</code><br /><code>print("Hello, World!") # Isn&rsquo;t this easy!</code></p>
                        <p><br />You&rsquo;ll also notice that we&rsquo;ve left a blank line in the program. Blank lines are also ignored by&nbsp;the interpreter, but comments and blank lines can make your programs much easier for humans to&nbsp;parse. Use them liberally!</p>
                        <p>&nbsp;</p>']);

    DB::insert('insert into guides (writerId , title, content) VALUE (?, ?, ?)',
                    [1, '2. Variables, expressions and statements',
                        '<h2>2.1 Values and data types</h2>
                        <p>A <strong>value</strong> is one of the fundamental things &mdash; like a letter or a number &mdash; that a program manipulates.<br />The values we have seen so far are <code>4</code> (the result when we added <code>2 + 2</code>), and "<code>Hello,&nbsp;World!</code>".<br />These values are classified into different <strong>classes</strong>, or <strong>data types</strong>: 4 is an <em>integer</em>, and <code>"Hello,&nbsp;World!</code>" is a <strong>string</strong>, so-called because it contains a string of letters. You (and the interpreter) can<br />identify strings because they are enclosed in quotation marks.<br />If you are not sure what class a value falls into, Python has a function called type which can tell&nbsp;you.<br /><code>&gt;&gt;&gt; type("Hello, World!")</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type(17)</code><br /><code>&lt;class &rsquo;int&rsquo;&gt;</code><br />Not surprisingly, strings belong to the class <strong>str</strong> and integers belong to the class <strong>int</strong>. Less obviously,&nbsp;numbers with a decimal point belong to a class called <strong>float</strong>, because these numbers are<br />represented in a format called <em>floating-point</em>. At this stage, you can treat the words <em>class</em> and <em>type</em>&nbsp;interchangeably. We&rsquo;ll come back to a deeper understanding of what a class is in later chapters.<br /><code>&gt;&gt;&gt; type(3.2)</code><br /><code>&lt;class &rsquo;float&rsquo;&gt;</code><br />What about values like "17" and "3.2"? They look like numbers, but they are in quotation&nbsp;marks like strings.<br /><code>&gt;&gt;&gt; type("17")</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type("3.2")</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br />They&rsquo;re strings!<br />Strings in Python can be enclosed in either single quotes (&rsquo;) or double quotes ("), or three of each&nbsp;(&rdquo;&rsquo; or """)<br /><code>&gt;&gt;&gt; type(&rsquo;This is a string.&rsquo;)</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type("And so is this.")</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type("""and this.""")</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type(&rsquo;&rsquo;&rsquo;and even this...&rsquo;&rsquo;&rsquo;)</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br />Double quoted strings can contain single quotes inside them, as in "<code>Bruce&rsquo;s beard</code>", and&nbsp;single quoted strings can have double quotes inside them, as in &rsquo;<code>The knights who say&nbsp;"Ni!"</code>&rsquo;.<br />Strings enclosed with three occurrences of either quote symbol are called triple quoted strings.<br />They can contain either single or double quotes:<br /><code>&gt;&gt;&gt; print(&rsquo;&rsquo;&rsquo;"Oh no", she exclaimed, "Ben&rsquo;s bike is broken!"&rsquo;&rsquo;&rsquo;)</code><br /><code>"Oh no", she exclaimed, "Ben&rsquo;s bike is broken!"</code><br /><code>&gt;&gt;&gt;</code><br />Triple quoted strings can even span multiple lines:<br /><code>&gt;&gt;&gt; message = """This message will</code><br /><code>... span several</code><br /><code>... lines."""</code><br /><code>&gt;&gt;&gt; print(message)</code><br /><code>This message will</code><br /><code>span several</code><br /><code>lines.</code><br /><code>&gt;&gt;&gt;</code><br />Python doesn&rsquo;t care whether you use single or double quotes or the three-of-a-kind quotes to surround&nbsp;your strings: once it has parsed the text of your program or command, the way it stores the&nbsp;value is identical in all cases, and the surrounding quotes are not part of the value. But when the&nbsp;interpreter wants to display a string, it has to decide which quotes to use to make it look like a&nbsp;string.<br /><code>&gt;&gt;&gt; &rsquo;This is a string.&rsquo;</code><br /><code>&rsquo;This is a string.&rsquo;</code><br /><code>&gt;&gt;&gt; """And so is this."""</code><br /><code>&rsquo;And so is this.&rsquo;</code><br />So the Python language designers usually chose to surround their strings by single quotes. What&nbsp;do think would happen if the string already contained single quotes? Try it for yourself and see.<br />When you type a large integer, you might be tempted to use commas between groups of three&nbsp;digits, as in 42,000. This is not a legal integer in Python, but it does mean something else, which&nbsp;is legal:<br /><code>&gt;&gt;&gt; 42000</code><br /><code>42000</code><br /><code>&gt;&gt;&gt; 42,000</code><br /><code>(42, 0)</code><br />Well, that&rsquo;s not what we expected at all! Because of the comma, Python chose to treat this as a&nbsp;<em>pair</em> of values. We&rsquo;ll come back to learn about pairs later. But, for the moment, remember not to&nbsp;put commas or spaces in your integers, no matter how big they are. Also revisit what we said in the&nbsp;previous chapter: formal languages are strict, the notation is concise, and even the smallest change&nbsp;might mean something quite different from what you intended.</p>
                        <h2><br />2.2 Variables</h2>
                        <p>One of the most powerful features of a programming language is the ability to manipulate <strong>variables</strong>.<br />A variable is a name that refers to a value.<br /><strong>Assignment statements</strong> create new variables and give them values:<br /><code>&gt;&gt;&gt; message = "And now for something completely different"</code><br /><code>&gt;&gt;&gt; n = 17</code><br /><code>&gt;&gt;&gt; pi = 3.14159</code><br />This example makes three assignments. The first assigns the string value "What&rsquo;s up, Doc?"&nbsp;to a new variable named message. The second gives the integer 17 to n, and the third assigns&nbsp;the floating-point number 3.14159 to a variable called pi.<br />The <strong>assignment token</strong>, =, should not be confused with equals, which uses the token ==. The&nbsp;assignment statement links a name, on the left hand side of the operator, with a value, on the right&nbsp;hand side. This is why you will get an error if you enter:<br /><code>&gt;&gt;&gt; 17 = n</code><br /><strong>Tip</strong>: When reading or writing code, say to yourself &ldquo;n is assigned 17&rdquo; or &ldquo;n gets the value 17&rdquo;.&nbsp;Don&rsquo;t say &ldquo;n equals 17&rdquo;.<br /><strong>Note</strong>: In case you are wondering, a token is a character or string of characters that has syntactic&nbsp;meaning in a language. In Python operators, keywords, literals, and white space all form tokens in&nbsp;the language.<br />A common way to represent variables on paper is to write the name with an arrow pointing to the&nbsp;variable&rsquo;s value. This kind of figure is called a <strong>state snapshot</strong> because it shows what state each of&nbsp;the variables is in at a particular instant in time. (Think of it as the variable&rsquo;s state of mind). This&nbsp;diagram shows the result of executing the assignment statements:</p>
                        <p><img src="http://www.greenteapress.com/thinkpython/html/thinkpython003.png" alt="" width="350" height="71" /><br />If you ask the interpreter to evaluate a variable, it will produce the value that is currently linked to&nbsp;the variable:<br /><code>&gt;&gt;&gt; message</code><br /><code>&rsquo;And now for something completely different&rsquo;</code><br /><code>&gt;&gt;&gt; n</code><br /><code>17</code><br /><code>&gt;&gt;&gt; pi</code><br /><code>3.14159</code><br />In each case the result is the value of the variable. Variables also have types; again, we can ask the&nbsp;interpreter what they are.<br /><code>&gt;&gt;&gt; type(message)</code><br /><code>&lt;class &rsquo;str&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type(n)</code><br /><code>&lt;class &rsquo;int&rsquo;&gt;</code><br /><code>&gt;&gt;&gt; type(pi)</code><br /><code>&lt;class &rsquo;float&rsquo;&gt;</code><br />The type of a variable is the type of the value it currently refers to.<br />We use variables in a program to &ldquo;remember&rdquo; things, like the current score at the football game.<br />But variables are <em>variable</em>. This means they can change over time, just like the scoreboard at a&nbsp;football game. You can assign a value to a variable, and later assign a different value to the same&nbsp;variable.<br /><strong>Note</strong>: This is different from math. In math, if you give x the value 3, it cannot change to link to a&nbsp;different value half-way through your calculations!<br /><code>&gt;&gt;&gt; day = "Thursday"</code><br /><code>&gt;&gt;&gt; day</code><br /><code>&rsquo;Thursday&rsquo;</code><br /><code>&gt;&gt;&gt; day = "Friday"</code><br /><code>&gt;&gt;&gt; day</code><br /><code>&rsquo;Friday&rsquo;</code><br /><code>&gt;&gt;&gt; day = 21</code><br /><code>&gt;&gt;&gt; day</code><br /><code>21</code><br />You&rsquo;ll notice we changed the value of <code>day</code> three times, and on the third assignment we even gave&nbsp;it a value that was of a different type.<br />A great deal of programming is about having the computer remember things, e.g. <em>The number of&nbsp;missed calls on your phone</em>, and then arranging to update or change the variable when you miss&nbsp;another call.</p>
                        <h2><br />2.3 Variable names and keywords</h2>
                        <p>Valid <strong>variable names</strong> in Python must conform to the following three simple rules:</p>
                        <p style="padding-left: 30px;">1. They are an arbitrarily long sequence of letters and digits.<br />2. The sequence must begin with a letter.<br />3. In addtion to a..z, and A..Z, the underscore (_) is a letter.</p>
                        <p>Although it is legal to use uppercase letters, by convention we don&rsquo;t. If you do, remember that case&nbsp;matters. <code>Bruce</code> and <code>bruce</code> are different variables.<br />The underscore character ( _) can appear in a name. It is often used in names with multiple words,&nbsp;such as <code>my_name</code> or <code>price_of_tea_in_china</code>.<br />There are some situations in which names beginning with an underscore have special meaning, so&nbsp;a safe rule for beginners is to start all names with a letter other than the underscore.<br />If you give a variable an illegal name, you get a syntax error:<br /><code>&gt;&gt;&gt; 76trombones = "big parade"</code><br /><code>SyntaxError: invalid syntax</code><br /><code>&gt;&gt;&gt; more$ = 1000000</code><br /><code>SyntaxError: invalid syntax</code><br /><code>&gt;&gt;&gt; class = "Computer Science 101"</code><br /><code>SyntaxError: invalid syntax</code><br /><code>76trombones</code> is illegal because it does not begin with a letter. <code>more$</code> is illegal because it&nbsp;contains an illegal character, the dollar sign. But what&rsquo;s wrong with <code>class</code>?<br />It turns out that <code>class</code> is one of the Python <strong>keywords</strong>. Keywords define the language&rsquo;s syntax&nbsp;rules and structure, and they cannot be used as variable names.<br />Python has thirty-something keywords (and every now and again improvements to Python introduce&nbsp;or eliminate one or two):</p>
                        <table style="height: 78px;" width="607">
                        <tbody>
                        <tr>
                        <td>and</td>
                        <td>as</td>
                        <td>assert</td>
                        <td>break</td>
                        <td>class</td>
                        <td>continue</td>
                        </tr>
                        <tr>
                        <td>def</td>
                        <td>del</td>
                        <td>elif</td>
                        <td>else</td>
                        <td>except</td>
                        <td>exec</td>
                        </tr>
                        <tr>
                        <td>finally</td>
                        <td>for</td>
                        <td>from</td>
                        <td>global</td>
                        <td>if</td>
                        <td>import</td>
                        </tr>
                        <tr>
                        <td>in</td>
                        <td>is</td>
                        <td>lambda</td>
                        <td>nonlocal</td>
                        <td>not</td>
                        <td>or</td>
                        </tr>
                        <tr>
                        <td>pass</td>
                        <td>raise</td>
                        <td>return</td>
                        <td>try</td>
                        <td>while</td>
                        <td>with</td>
                        </tr>
                        <tr>
                        <td>yield</td>
                        <td>True</td>
                        <td>False</td>
                        <td>None</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        </tr>
                        </tbody>
                        </table>
                        <p><br />You might want to keep this list handy. If the interpreter complains about one of your variable&nbsp;names and you don&rsquo;t know why, see if it is on this list.<br />Programmers generally choose names for their variables that are meaningful to the human readers&nbsp;of the program&mdash;they help the programmer document, or remember, what the variable is used for.</p>
                        <table style="height: 129px;" width="604">
                        <tbody>
                        <tr>
                        <td>Caution: Beginners sometimes confuse &ldquo;meaningful to the human readers&rdquo; with &ldquo;meaningful&nbsp;to the computer&rdquo;. So they&rsquo;ll wrongly think that because they&rsquo;ve called some variable average&nbsp;or pi, it will somehow automagically calculate an average, or automagically associate the variable&nbsp;pi with the value 3.14159. No! The computer doesn&rsquo;t attach semantic meaning to your&nbsp;variable names.<br />So you&rsquo;ll find some instructors who deliberately don&rsquo;t choose meaningful names when they&nbsp;teach beginners &mdash; not because they don&rsquo;t think it is a good habit, but because they&rsquo;re trying to&nbsp;reinforce the message that you, the programmer, have to write some program code to calculate&nbsp;the average, or you must write an assignment statement to give a variable the value you want it&nbsp;to have.</td>
                        </tr>
                        </tbody>
                        </table>
                        <p>&nbsp;</p>
                        <h2>2.4 Statements</h2>
                        <p>A <strong>statement</strong> is an instruction that the Python interpreter can execute. We have only seen the&nbsp;assignment statement so far. Some other kinds of statements that we&rsquo;ll see shortly are <code>while</code>&nbsp;statements, <code>for</code> statements, <code>if</code> statements, and <code>import</code> statements. (There are other kinds too!)&nbsp;When you type a statement on the command line, Python executes it. Statements don&rsquo;t produce&nbsp;any result.</p>
                        <h2><br />2.5 Evaluating expressions</h2>
                        <p>An <strong>expression</strong> is a combination of values, variables, operators, and calls to functions. If you type&nbsp;an expression at the Python prompt, the interpreter <strong>evaluates</strong> it and displays the result:<br /><code>&gt;&gt;&gt; 1 + 1</code><br /><code>2</code><br /><code>&gt;&gt;&gt; len("hello")</code><br /><code>5</code><br />In this example <code>len</code> is a built-in Python function that returns the number of characters in a string.<br />We&rsquo;ve previously seen the <code>print</code> and the <code>type</code> functions, so this is our third example of a function!<br />The <em>evaluation</em> of an <em>expression</em> produces a value, which is why expressions can appear on the&nbsp;right hand side of assignment statements. A value all by itself is a simple expression, and so is a&nbsp;variable.<br /><code>&gt;&gt;&gt; 17</code><br /><code>17</code><br /><code>&gt;&gt;&gt; y = 3.14</code><br /><code>&gt;&gt;&gt; x = len("hello")</code><br /><code>&gt;&gt;&gt; x</code><br /><code>5</code><br /><code>&gt;&gt;&gt; y</code><br /><code>3.14</code></p>
                        <h2><br />2.6 Operators and operands</h2>
                        <p>Operators are special tokens that represent computations like addition, multiplication and division.&nbsp;The values the operator uses are called <strong>operands</strong>.<br />The following are all legal Python expressions whose meaning is more or less clear:<br /><code>20 + 32 hour - 1 hour * 60 + minute minute / 60 5 ** 2</code><br /><code>(5 + 9) * (15 - 7)</code><br />The tokens +, -, and *, and the use of parenthesis for grouping, mean in Python what they mean&nbsp;in mathematics. The asterisk (*) is the token for multiplication, and ** is the token for exponentiation.<br /><code>&gt;&gt;&gt; 2 ** 3</code><br /><code>8</code><br /><code>&gt;&gt;&gt; 3 ** 2</code><br /><code>9</code><br />When a variable name appears in the place of an operand, it is replaced with its value before the&nbsp;operation is performed.<br />Addition, subtraction, multiplication, and exponentiation all do what you expect.<br />Example: so let us convert 645 minutes into hours:<br /><code>&gt;&gt;&gt; minutes = 645</code><br /><code>&gt;&gt;&gt; hours = minutes / 60</code><br /><code>&gt;&gt;&gt; hours</code><br /><code>10.75</code><br />Oops! In Python 3, the division operator / always yields a floating point result. What we might&nbsp;have wanted to know was how many <em>whole</em> hours there are, and how many minutes remain. Python&nbsp;gives us two different flavours of the division operator. The second, called <strong>integer division</strong> uses&nbsp;the token //. It always <em>truncates</em> its result down to the next smallest integer (to the left on the&nbsp;number line).<br /><code>&gt;&gt;&gt; 7 / 4</code><br /><code>1.75</code><br /><code>&gt;&gt;&gt; 7 // 4</code><br /><code>1</code><br /><code>&gt;&gt;&gt; minutes = 645</code><br /><code>&gt;&gt;&gt; hours = minutes // 60</code><br /><code>&gt;&gt;&gt; hours</code><br /><code>10</code><br />Take care that you choose the correct falvour of the division operator. If you&rsquo;re working with&nbsp;expressions where you need floating point values, use the division operator that does the division&nbsp;accurately.</p>
                        <h2><br />2.7 Type converter functions</h2>
                        <p>Here we&rsquo;ll look at three more Python functions, <code>int</code>, <code>float</code> and <code>str</code>, which will (attempt to)&nbsp;convert their arguments into types <code>int</code>, <code>float</code> and <code>str</code> respectively. We call these type converter&nbsp;functions.<br />The <code>int</code> function can take a floating point number or a string, and turn it into an int. For floating&nbsp;point numbers, it <em>discards</em> the decimal portion of the number - a process we call <em>truncation towards&nbsp;zero</em> on the number line. Let us see this in action:<br />&gt;&gt;<code>&gt; int(3.14)</code><br /><code>3</code><br /><code>&gt;&gt;&gt; int(3.9999) # This doesn&rsquo;t round to the closest int!</code><br /><code>3</code><br /><code>&gt;&gt;&gt; int(3.0)</code><br /><code>3</code><br /><code>&gt;&gt;&gt; int(-3.999) # Note that the result is closer to zero</code><br /><code>-3</code><br /><code>&gt;&gt;&gt; int(minutes/60)</code><br /><code>10</code><br /><code>&gt;&gt;&gt; int("2345") # parse a string to produce an int</code><br /><code>2345</code><br /><code>&gt;&gt;&gt; int(17) # int even works if its argument is already an int</code><br /><code>17</code><br /><code>&gt;&gt;&gt; int("23 bottles")</code><br /><code>Traceback (most recent call last):</code><br /><code>File "&lt;interactive input&gt;", line 1, in &lt;module&gt;</code><br /><code>ValueError: invalid literal for int() with base 10: &rsquo;23 bottles&rsquo;</code><br />The last case shows that a string has to be a syntactically legal number, otherwise you&rsquo;ll get one of&nbsp;those pesky runtime errors.<br />The type converter <code>float</code> can turn an integer, a float, or a syntactically legal string into a float.<br /><code>&gt;&gt;&gt; float(17)</code><br /><code>17.0</code><br /><code>&gt;&gt;&gt; float("123.45")</code><br /><code>123.45</code><br /><code>The type converter str turns its argument into a string:</code><br /><code>&gt;&gt;&gt; str(17)</code><br /><code>&rsquo;17&rsquo;</code><br /><code>&gt;&gt;&gt; str(123.45)</code><br /><code>&rsquo;123.45&rsquo;</code></p>
                        <p>&nbsp;</p>
                        <h2>2.8 Order of operations</h2>
                        <p>When more than one operator appears in an expression, the order of evaluation depends on the&nbsp;<strong>rules of precedence</strong>. Python follows the same precedence rules for its mathematical operators that&nbsp;mathematics does. The acronym PEMDAS is a useful way to remember the order of operations:</p>
                        <p style="padding-left: 30px;">1. <strong>P</strong>arentheses have the highest precedence and can be used to force an expression to evaluate&nbsp;in the order you want. Since expressions in parentheses are evaluated first, <code>2 * (3-1)</code> is&nbsp;4, and <code>(1+1)**(5-2)</code> is 8. You can also use parentheses to make an expression easier to&nbsp;read, as in <code>(minute * 100) / 60</code>, even though it doesn&rsquo;t change the result.<br />2. <strong>E</strong>xponentiation has the next highest precedence, so <code>2**1+1</code> is 3 and not 4, and <code>3*1**3</code> is&nbsp;3 and not 27.<br />3. <strong>M</strong>ultiplication and both <strong>D</strong>ivision operators have the same precedence, which is higher than&nbsp;Addition and Subtraction, which also have the same precedence. So <code>2*3-1</code> yields 5 rather&nbsp;than 4, and <code>5-2*2</code> is 1, not 6. #. Operators with the <em>same</em> precedence are evaluated from&nbsp;left-to-right. In algebra we say they are <em>left-associative</em>. So in the expression <code>6-3+2</code>, the&nbsp;subtraction happens first, yielding 3. We then add 2 to get the result 5. If the operations had&nbsp;been evaluated from right to left, the result would have been <code>6-(3+2)</code>, which is 1. (The&nbsp;acronym PEDMAS could mislead you to thinking that division has higher precedence than&nbsp;multiplication, and addition is done ahead of subtraction - don&rsquo;t be misled. Subtraction and&nbsp;addition are at the same precedence, and the left-to-right rule applies.)&nbsp;</p>
                        <p><strong>Note</strong>: Due to some historical quirk, an exception to the left-to-right left-associative rule is the&nbsp;exponentiation operator **, so a useful hint is to always use parentheses to force exactly the order&nbsp;you want when exponentiation is involved:<br /><code>&gt;&gt;&gt; 2 ** 3 ** 2 # the right-most ** operator gets done first!</code><br /><code>512</code><br /><code>&gt;&gt;&gt; (2 ** 3) ** 2 # use parentheses to force the order you want!</code><br /><code>64</code><br />The immediate mode command prompt of Python is great for exploring and experimenting with&nbsp;expressions like this.</p>
                        <h2><br />2.9 Operations on strings</h2>
                        <p><br />In general, you cannot perform mathematical operations on strings, even if the strings look like&nbsp;numbers. The following are illegal (assuming that <code>message</code> has type string):<br /><code>message - 1 "Hello" / 123 message * "Hello" "15" + 2</code><br />Interestingly, the + operator does work with strings, but for strings, the + operator represents&nbsp;<strong>concatenation</strong>, not addition. Concatenation means joining the two operands by linking them end-to-end. For example:<br /><code>fruit = "banana"</code><br /><code>baked_good = " nut bread"</code><br /><code>print(fruit + baked_good)</code><br />The output of this program is <code>banana nut bread</code>. The space before the word <code>nut</code> is part of&nbsp;the string, and is necessary to produce the space between the concatenated strings.<br />The * operator also works on strings; it performs repetition. For example, &rsquo;<code>Fun&rsquo;*3</code> is&nbsp;&rsquo;<code>FunFunFun</code>&rsquo;. One of the operands has to be a string; the other has to be an integer.<br />On one hand, this interpretation of + and * makes sense by analogy with addition and multiplication.<br />Just as <code>4*3</code> is equivalent to <code>4+4+4</code>, we expect "<code>Fun"*3</code> to be the same as<code>&nbsp;"Fun"+"Fun"+"Fun"</code>, and it is. On the other hand, there is a significant way in which string&nbsp;concatenation and repetition are different from integer addition and multiplication. Can you think&nbsp;of a property that addition and multiplication have that string concatenation and repetition do not?</p>
                        <h2><br />2.10 Input</h2>
                        <p>There is a built-in function in Python for getting input from the user:<br /><code>name = input("Please enter your name: ")</code><br />The user of the program can enter the name and press <code>return</code>. When this happens the text that&nbsp;has been entered is returned from the <code>input</code> function, and in this case assigned to the variable&nbsp;<code>name</code>.<br />Even if you asked the user to enter their age, you would get back a string like "<code>17</code>". It would be&nbsp;your job, as the programmer, to convert that string into a int or a float, using the <code>int</code> or <code>float</code>&nbsp;converter functions we saw earlier.</p>
                        <p>&nbsp;</p>
                        <h2>2.11 Composition</h2>
                        <p>So far, we have looked at the elements of a program &mdash; variables, expressions, statements, and&nbsp;function calls &mdash; in isolation, without talking about how to combine them.<br />One of the most useful features of programming languages is their ability to take small building&nbsp;blocks and <strong>compose</strong> them into larger chunks.<br />For example, we know how to get the user to enter some input, we know how to convert the string&nbsp;we get into a float, we know how to write a complex expression, and we know how to print values.<br />Let&rsquo;s put these together in a small four-step program that asks the user to input a value for the&nbsp;radius of a circle, and then computes the area of the circle from the formula&nbsp;</p>
                        <p><img src="http://upload.wikimedia.org/math/f/2/c/f2c4b9606fb5f2702616adae4f94f83d.png" alt="" width="74" height="18" /></p>
                        <p>Firstly, we&rsquo;ll do the four steps one at a time:<br /><code>response = input("What is your radius? ")</code><br /><code>r = float(response)</code><br /><code>area = 3.14159 * r**2</code><br /><code>print("The area is ", area)</code><br />Now let&rsquo;s compose the first two lines into a single line of code, and compose the second two lines&nbsp;into another line of code.<br /><code>r = float(input("What is your radius? "))</code><br /><code>print("The area is ", 3.14159 * r**2)</code><br />If we really wanted to be tricky, we could write it all in one statement:<br /><code>print("The area is ", 3.14159*float(input("What is your radius?"))**2)</code><br />Such compact code may not be most understandable for humans, but it does illustrate how we can&nbsp;compose bigger chunks from our building blocks.<br />If you&rsquo;re ever in doubt about whether to compose code or fragment it into smaller steps, try to&nbsp;make it as simple as you can for the human to follow. My choice would be the first case above,&nbsp;with four separate steps.</p>']);

    }
}