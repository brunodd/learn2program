<?php

use Illuminate\Database\Seeder;

class GuidesTableSeeder extends Seeder {

    public function run() {
        DB::table('guides')->delete();

        DB::insert('insert into guides (writerId , title, content) VALUE (?, ?, ?)',
                    [1, '1. The way of the program','
                        <p>The goal of this book is to teach you to think like a computer scientist. This way of thinking&nbsp;combines some of the best features of mathematics, engineering, and natural science. Like mathematicians,&nbsp;computer scientists use formal languages to denote ideas (specifically computations).<br />Like engineers, they design things, assembling components into systems and evaluating tradeoffs&nbsp;among alternatives. Like scientists, they observe the behavior of complex systems, form hypotheses,&nbsp;and test predictions.<br />The single most important skill for a computer scientist is <strong>problem solving</strong>. Problem solving&nbsp;means the ability to formulate problems, think creatively about solutions, and express a solution<br />clearly and accurately. As it turns out, the process of learning to program is an excellent opportunity&nbsp;to practice problem-solving skills. That&rsquo;s why this chapter is called, The way of the program.<br />On one level, you will be learning to program, a useful skill by itself. On another level, you will&nbsp;use programming as a means to an end. As we go along, that end will become clearer.</p>
                        <h2><br />1.1 The Python programming language</h2>
                        <p><br />The programming language you will be learning is Python. Python is an example of a <strong>high-level&nbsp;</strong><strong>language</strong>; other high-level languages you might have heard of are C++, PHP, and Java.<br />As you might infer from the name high-level language, there are also <strong>low-level languages</strong>, sometimes&nbsp;referred to as machine languages or assembly languages. Loosely speaking, computers can&nbsp;only execute programs written in low-level languages. Thus, programs written in a high-level language&nbsp;have to be processed before they can run. This extra processing takes some time, which is a&nbsp;small disadvantage of high-level languages.<br />But the advantages are enormous. First, it is much easier to program in a high-level language.&nbsp;Programs written in a high-level language take less time to write, they are shorter and easier to&nbsp;read, and they are more likely to be correct. Second, high-level languages are <strong>portable</strong>, meaning&nbsp;that they can run on different kinds of computers with few or no modifications. Low-level programs&nbsp;can run on only one kind of computer and have to be rewritten to run on another.<br />Due to these advantages, almost all programs are written in high-level languages. Low-level languages&nbsp;are used only for a few specialized applications.<br />Two kinds of programs process high-level languages into low-level languages: <strong>interpreters</strong> and&nbsp;<strong>compilers</strong>. An interpreter reads a high-level program and executes it, meaning that it does what the&nbsp;program says. It processes the program a little at a time, alternately reading lines and performing&nbsp;computations.</p>
                        <p><img src="http://www.greenteapress.com/thinkpython/html/thinkpython001.png" alt="" width="332" height="79" /></p>
                        <p>A compiler reads the program and translates it completely before the program starts running. In&nbsp;this case, the high-level program is called the <strong>source code</strong>, and the translated program is called the<br /><strong>object code</strong> or the <strong>executable</strong>. Once a program is compiled, you can execute it repeatedly without&nbsp;further translation.</p>
                        <p><img src="http://www.greenteapress.com/thinkpython/html/thinkpython002.png" alt="" width="484" height="79" /><br />Many modern languages use both processes. They are first compiled into a lower level language,&nbsp;called <strong>byte code</strong>, and then interpreted by a program called a <strong>virtual machine</strong>. Python uses both&nbsp;processes, but because of the way programmers interact with it, it is usually considered an interpreted&nbsp;language.</p>
                        <p><br />There are two ways to use the Python interpreter: <em>shell mode</em> and <em>script mode</em>. In shell mode, you<br />type Python expressions into the <strong>Python shell</strong>, and the interpreter immediately shows the result:</p>
                        <p><code>$ python3</code><br /><code>Python 3.2 (r32:88445, Mar 25 2011, 19:28:28)</code><br /><code>[GCC 4.5.2] on linux2</code><br /><code>Type "help", "copyright", "credits" or "license" for more information.</code><br /><code>&gt;&gt;&gt; 2 + 2</code><br /><code>4</code><br /><code>&gt;&gt;&gt;</code></p>
                        <p><br />The &gt;&gt;&gt; is called the <strong>Python prompt</strong>. The interpreter uses the prompt to indicate that it is ready&nbsp;for instructions. We typed 2 + 2, and the interpreter evaluated our expression, and replied 4, and<br />on the next line it gave a new prompt, indicating that it is ready for more input.<br />Alternatively, you can write a program in a file and use the interpreter to execute the contents of&nbsp;the file. Such a file is called a <strong>script</strong>. For example, we used a text editor to create a file named&nbsp;firstprogram.py with the following contents:</p>
                        <p><br /><code>print("My first program adds two numbers, 2 and 3:")</code><br /><code>print(2 + 3)</code></p>
                        <p><br />By convention, files that contain Python programs have names that end with <code>.py</code> . Following this&nbsp;convention will help your operating system and other programs identify a file as containing python&nbsp;code.</p>
                        <p><br /><code>$ python firstprogram.py</code><br /><code>My first program adds two numbers, 2 and 3:</code><br /><code>5</code></p>
                        <p><br />These examples show Python being run from a Unix command line. In other development environments,&nbsp;the details of executing programs may differ. Also, most programs are more interesting&nbsp;than this one.<br />The examples in this book use both the Python interpreter and scripts. You will be able to tell&nbsp;which is intended since shell mode examples will always start with the Python prompt.<br />Working directly in the interpreter is convenient for testing short bits of code because you get&nbsp;immediate feedback. Think of it as scratch paper used to help you work out problems. Anything&nbsp;longer than a few lines should be put into a script.</p>
                        <h2><br />1.2 What is a program?</h2>
                        <p><br />A <strong>program</strong> is a sequence of instructions that specifies how to perform a computation. The computation&nbsp;might be something mathematical, such as solving a system of equations or finding the&nbsp;roots of a polynomial, but it can also be a symbolic computation, such as searching and replacing&nbsp;text in a document or (strangely enough) compiling a program.<br />The details look different in different languages, but a few basic instructions appear in just about&nbsp;every language:</p>
                        <p style="padding-left: 30px;"><br /><strong>input</strong> Get data from the keyboard, a file, or some other device.<br /><strong>output</strong> Display data on the screen or send data to a file or other device.<br /><strong>math and logic</strong> Perform basic mathematical operations like addition, and multiplication, and logical&nbsp;operations like and, or, and not.<br /><strong>conditional execution</strong> Check for certain conditions and execute the appropriate sequence of statements.<br /><strong>repetition</strong> Perform some action repeatedly, usually with some variation.</p>
                        <p>Believe it or not, that&rsquo;s pretty much all there is to it. Every program you&rsquo;ve ever used, no matter&nbsp;how complicated, is made up of instructions that look more or less like these. Thus, we can describe&nbsp;programming as the process of breaking a large, complex task into smaller and smaller subtasks&nbsp;until the subtasks are simple enough to be performed with sequences of these basic instructions.<br />That may be a little vague, but we will come back to this topic later when we talk about algorithms.</p>
                        <h2><br />1.3 What is debugging?</h2>
                        <p><br />Programming is a complex process, and because it is done by human beings, it often leads to errors.<br />Programming errors are called <strong>bugs</strong> and the process of tracking them down and correcting them is&nbsp;called <strong>debugging</strong>. Some claim that in 1945, a dead moth caused a problem on relay number 70,&nbsp;panel F, of one of the first computers at Harvard, and the term <strong>bug</strong> has remained in use since.<br />Three kinds of errors can occur in a program: <em>syntax errors</em>, <em>runtime errors</em>, and <em>semantic errors</em>. It&nbsp;is useful to distinguish between them in order to track them down more quickly.</p>
                        <h2><br />1.4 Syntax errors</h2>
                        <p>Python can only execute a program if the program is syntactically correct; otherwise, the process&nbsp;fails and returns an error message. <strong>Syntax</strong> refers to the structure of a program and the rules about<br />that structure. For example, in English, a sentence must begin with a capital letter and end with a&nbsp;period. this sentence contains a <strong>syntax error</strong>. So does this one&nbsp;</p>
                        <p>For most readers, a few syntax errors are not a significant problem, which is why we can read the&nbsp;poetry of e. e. cummings without problems. Python is not so forgiving. If there is a single syntax&nbsp;error anywhere in your program, Python will display an error message and quit, and you will not&nbsp;be able to run your program. During the first few weeks of your programming career, you will&nbsp;probably spend a lot of time tracking down syntax errors. As you gain experience, though, you&nbsp;will make fewer errors and find them faster.</p>
                        <h2>1.5 Runtime errors</h2>
                        <p>The second type of error is a runtime error, so called because the error does not appear until you run&nbsp;the program. These errors are also called <strong>exceptions</strong> because they usually indicate that something&nbsp;exceptional (and bad) has happened.<br />Runtime errors are rare in the simple programs you will see in the first few chapters, so it might be&nbsp;a while before you encounter one.</p>
                        <h2><br />1.6 Semantic errors</h2>
                        <p>The third type of error is the <strong>semantic error</strong>. If there is a semantic error in your program, it will&nbsp;run successfully, in the sense that the computer will not generate any error messages, but it will&nbsp;not do the right thing. It will do something else. Specifically, it will do what you told it to do.<br />The problem is that the program you wrote is not the program you wanted to write. The meaning of&nbsp;the program (its semantics) is wrong. Identifying semantic errors can be tricky because it requires&nbsp;you to work backward by looking at the output of the program and trying to figure out what it is&nbsp;doing.</p>
                        <h2><br />1.7 Experimental debugging</h2>
                        <p>One of the most important skills you will acquire is debugging. Although it can be frustrating,&nbsp;debugging is one of the most intellectually rich, challenging, and interesting parts of programming.<br />In some ways, debugging is like detective work. You are confronted with clues, and you have to&nbsp;infer the processes and events that led to the results you see.<br />Debugging is also like an experimental science. Once you have an idea what is going wrong, you&nbsp;modify your program and try again. If your hypothesis was correct, then you can predict the result<br />of the modification, and you take a step closer to a working program. If your hypothesis was&nbsp;wrong, you have to come up with a new one. As Sherlock Holmes pointed out, When you have<br />eliminated the impossible, whatever remains, however improbable, must be the truth. (A. Conan&nbsp;Doyle, <em>The Sign of Four</em>)<br />For some people, programming and debugging are the same thing. That is, programming is the&nbsp;process of gradually debugging a program until it does what you want. The idea is that you should<br />start with a program that does <em>something</em> and make small modifications, debugging them as you&nbsp;go, so that you always have a working program.<br />For example, Linux is an operating system kernel that contains millions of lines of code, but it&nbsp;started out as a simple program Linus Torvalds used to explore the Intel 80386 chip. According<br />to Larry Greenfield, one of Linus&rsquo;s earlier projects was a program that would switch between&nbsp;displaying AAAA and BBBB. This later evolved to Linux (<em>The Linux Users&rsquo; Guide</em> Beta Version&nbsp;1).<br />Later chapters will make more suggestions about debugging and other programming practices.</p>
                        <h2><br />1.8 Formal and natural languages</h2>
                        <p><strong>Natural languages</strong> are the languages that people speak, such as English, Spanish, and French.<br />They were not designed by people (although people try to impose some order on them); they&nbsp;evolved naturally.<br /><strong>Formal languages</strong> are languages that are designed by people for specific applications. For example,&nbsp;the notation that mathematicians use is a formal language that is particularly good at denoting<br />relationships among numbers and symbols. Chemists use a formal language to represent the chemical&nbsp;structure of molecules. And most importantly:<br /><em>Programming languages are formal languages that have been designed to express&nbsp;computations.</em><br />Formal languages tend to have strict rules about syntax. For example, <code>3+3=6</code> is a syntactically&nbsp;correct mathematical statement, but <code>3=+6$</code> is not. H<sub>2</sub>O is a syntactically correct chemical name,<br />but 2Zz is not.<br />Syntax rules come in two flavors, pertaining to <strong>tokens</strong> and structure. Tokens are the basic elements&nbsp;of the language, such as words, numbers, and chemical elements. One of the problems with <code>3=+6$</code><br /><br />is that <code>$</code> is not a legal token in mathematics (at least as far as we know). Similarly, <sub>2</sub>Zz is not legal&nbsp;because there is no element with the abbreviation Zz.<br />The second type of syntax rule pertains to the <strong>structure</strong> of a statement&mdash; that is, the way the&nbsp;tokens are arranged. The statement <code>3=+6$</code> is structurally illegal because you can&rsquo;t place a plus<br />sign immediately after an equal sign. Similarly, molecular formulas have to have subscripts after&nbsp;the element name, not before.<br />When you read a sentence in English or a statement in a formal language, you have to figure out&nbsp;what the structure of the sentence is (although in a natural language you do this subconsciously).<br />This process is called <strong>parsing</strong>.<br />For example, when you hear the sentence, &ldquo;The other shoe fell&rdquo;, you understand that the other&nbsp;shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what&nbsp;it means, or the <strong>semantics</strong> of the sentence. Assuming that you know what a shoe is and what it&nbsp;means to fall, you will understand the general implication of this sentence.<br />Although formal and natural languages have many features in common&mdash;tokens, structure, syntax,&nbsp;and semantics &mdash; there are many differences:</p>
                        <p style="padding-left: 30px;"><strong>ambiguity</strong> Natural languages are full of ambiguity, which people deal with by using contextual&nbsp;clues and other information. Formal languages are designed to be nearly or completely unambiguous,&nbsp;which means that any statement has exactly one meaning, regardless of context.<br /><strong>redundancy</strong> In order to make up for ambiguity and reduce misunderstandings, natural languages&nbsp;employ lots of redundancy. As a result, they are often verbose. Formal languages are less<br />redundant and more concise.<br /><strong>literalness</strong> Formal languages mean exactly what they say. On the other hand, natural languages&nbsp;are full of idiom and metaphor. If someone says, &ldquo;The other shoe fell&rdquo;, there is probably no<br />shoe and nothing falling.</p>
                        <p>People who grow up speaking a natural language&mdash;everyone&mdash;often have a hard time adjusting to&nbsp;formal languages. In some ways, the difference between formal and natural language is like the<br />difference between poetry and prose, but more so:</p>
                        <p style="padding-left: 30px;"><strong>poetry</strong> Words are used for their sounds as well as for their meaning, and the whole poem together&nbsp;creates an effect or emotional response. Ambiguity is not only common but often deliberate.<br /><strong>prose</strong> The literal meaning of words is more important, and the structure contributes more meaning.&nbsp;Prose is more amenable to analysis than poetry but still often ambiguous.<br /><strong>program</strong> The meaning of a computer program is unambiguous and literal, and can be understood&nbsp;entirely by analysis of the tokens and structure.</p>
                        <p>Here are some suggestions for reading programs (and other formal languages). First, remember that formal languages are much more dense than natural languages, so it takes longer to read them.<br />Also, the structure is very important, so it is usually not a good idea to read from top to bottom, left&nbsp;to right. Instead, learn to parse the program in your head, identifying the tokens and interpreting&nbsp;the structure. Finally, the details matter. Little things like spelling errors and bad punctuation,&nbsp;which you can get away with in natural languages, can make a big difference in a formal language.</p>
                        <h2><br />1.9 The first program</h2>
                        <p>Traditionally, the first program written in a new language is called Hello, World! because all it&nbsp;does is display the words, Hello, World! In Python, the script looks like this:<br /><code>print("Hello, World!")</code><br />This is an example of using the print function, which doesn&rsquo;t actually print anything on paper. It&nbsp;displays a value on the screen. In this case, the result is the words&nbsp;</p>
                        <p><code>Hello, World!</code></p>
                        <p>The quotation marks in the program mark the beginning and end of the value; they don&rsquo;t appear in&nbsp;the result.<br />Some people judge the quality of a programming language by the simplicity of the Hello, World!&nbsp;program. By this standard, Python does about as well as possible.</p>
                        <h2><br />1.10 Comments</h2>
                        <p>As programs get bigger and more complicated, they get more difficult to read. Formal languages&nbsp;are dense, and it is often difficult to look at a piece of code and figure out what it is doing, or why.<br />For this reason, it is a good idea to add notes to your programs to explain in natural language what&nbsp;the program is doing.<br />A <strong>comment</strong> in a computer program is text that is intended only for the human reader - it is completely&nbsp;ignored by the interpreter.<br />In Python, the # token starts a comment. The rest of the line is ignored. Here is a new version of&nbsp;Hello, World!.</p>
                        <p><code>#---------------------------------------------------</code><br /><code># This demo program shows off how elegant Python is!</code><br /><code># Written by Joe Soap, December 2010.</code><br /><code># Anyone may freely copy or modify this program.</code><br /><code>#---------------------------------------------------</code><br /><code>print("Hello, World!") # Isn&rsquo;t this easy!</code></p>
                        <p><br />You&rsquo;ll also notice that we&rsquo;ve left a blank line in the program. Blank lines are also ignored by&nbsp;the interpreter, but comments and blank lines can make your programs much easier for humans to&nbsp;parse. Use them liberally!</p>
                        <p>&nbsp;</p>']);
    }
}