\subsubsection{Programmeertaal}
We zijn begonnen met het PHP framework \href{http://laravel.com/}{\emph{Laravel (5.0)}}.
Aangezien niemand van ons enige ervaring had met webdevelopment of webdesign was het een
enorme hulp om een soort template te hebben waar we op konden voortgaan. Een bijkomende reden
om Laravel te gebruiken is dat het een zeer uitgebreide en actieve community bevat, evenals veel en
duidelijke tutorials. \\
Laravel gebruikt MVC design, wat we dan ook gevolgd hebben. Voor alle grote paginas
werd een Controller aangemaakt. De Controllers bevatten de voornaamste php code. De resultaten die in de
Controller behaald worden, worden dan gebruikt om Views te cre\"{e}ren die de content geformatteerd renderen (als html code).

\subsubsection{Database communicatie}
Om met objecten te kunnen werken worden zogenaamde Models aangemaakt. Laravel gebruikt het Eloquent ORM om met die models
te werken. Aangezien we de functionaliteit van de Models niet mochten gebruiken voor het project,
hebben we zelf alle SQL queries geschreven en worden de Models enkel gebruikt als data containers.
De SQL queries worden verspreid door enkele files, en worden doorheen het programma gebruikt om te communiceren
met de database.

\subsubsection{Python interpreter}
Als python interpreter hebben we gekozen voor \href{http://www.skulpt.org/}{\emph{Skulpt}}.
Skulpt is een 'in-browser' implementatie van python. De voornaamste voordelen hiervan zijn dat
beveiliging veel minder belangrijk is, omdat het kwetsbare systeem voornamelijk de eigen computer
van de gebruiker is. Een tweede voordeel is dat de interpretatie van python code geen rekenkracht vergt van
de servers. Dit maakt dat het systeem voorbereid is voor gelijktijdig gebruik door een groot aantal gebruikers.
Een nadeel van dit systeem is dan weer dat Skulpt een implementatie is van Python, en dus niet hetzelfde is als de
werkelijke python interpreter. Hierdoor is skulpt niet hetzelfde als de officiele python interpreter. Na
afweging van voor- en nadelen hebben we besloten dat de voordelen zwaarder doorwegen. Voornamelijk omdat
de applicatie dient om te leren programmeren. De nadruk ligt dus op relatief eenvoudige problemen, waardoor
de meer gevorderde zaken die eventueel zouden ontbreken niet van toepassing zijn.

\subsubsection{C++ compiler}
Om oefeningen beschikbaar te maken in c++ werd gebruik gemaakt van een API aangeboden door
\href{http://coliru.stacked-crooked.com/}{\emph{Coliru}}. De c++ code wordt gecompileerd en uitgevoerd door Coliru,
waarna het resultaat van de code wordt terug gestuurd.

\subsubsection{Text editor en syntax highlighting}
\st{Als online text editor hebben we EditArea gebruikt.}
Raphael
bblablabla

\subsubsection{Oefeningen flow-control}
\begin{description}
\item[Reeksen] Bij het maken van een reeks, kan een gebruiker slechts in een vaste volgorde de oefeningen oplossen. Op deze manier is er
een mate van controle over de volgorde van oplossen. Het is echter niet vereist dat een gebruiker de oefening correct oplost
om verder te kunnen gaan, een enkele poging is voldoende.
\item[Exercises] De mogelijkheid om exercises op te lossen volgt het systeem van de reeksen hierboven beschreven. Indien je naar het
    overzicht van exercises navigeert, krijg je wel alle exercises te zien. Op deze manier kan je een specifieke oefening toevoegen 
    aan een eigen reeks, zonder dat je deze moet hebben opgelost.
\end{description}

\subsubsection{Score bepaling}
\begin{description}
\item[In een reeks] Om een zekere uniformiteit en objectiviteit te garanderen wordt iedere oefening binnen een reeks even zwaar gequoteerd. De score
    die een gebruiker op een reeks behaald is afhankelijk van het percentage van oefeningen binnen die reeks die hij correct heeft opgelost.
    Door moeilijke reeksen en makkelijke reeksen gelijk te quoteren, is het voor een beginner minder demotiverend om lage scores te halen
    (vergeleken met zeer gevorderde vrienden bijvoorbeeld).
\item[Op het leaderboard] De score van een gebruiker op het leaderboard wordt bepaald door het aantal oefeningen die hij heeft opgelost. Iedere oefening
    telt ook hier even zwaar door.
\item[Challenges] De score van een challenge stijgt iedere keer dat je een challenge wint. Het is dus mogelijk om meerdere punten te verdienen aan een enkele
    challenge. Indien een gebruiker en zijn uitdager om beurten elkaar verslaan stijgt hun score tot ze allebei hun beste resultaat hebben behaald. De bedoeling
    is dat een gebruiker gemotiveerd wordt om zo snel mogelijk te programmeren.

\subsubsection{Sociaal}
\begin{description}
\item[Vrienden] Een gebruiker kan vrienden maken. Dit doet hij door een vriendschapsverzoek te verzenden. Dit verzoek moet dan weer door
de potentiele vriend aanvaard worden. Iedere gebruiker heeft volledige controle over wie hij/zij bevriend. Nadat een vriendschapsverzoek
geaccepteerd werd, kan iedere vriend dit annuleren. Een vriendschap is nu eenmaal niet definitief. \\
Indien een vriendschap geweigerd werd, kan de aanvrager geen verzoek meet verzenden, dit om spam te vermijden.
\item[Groepen] Een gebruiker kan een groep aanmaken of lid worden van een bestaande groep. Het voornaamste verschil met vrienden is dat
een gebruiker geen controle heeft over wie er mede-lid wordt van een groep. Uiteraard kan iedere gebruiker, met uizondering van de oprichter,
ook de groep weer verlaten.
\end{description}

\subsubsection{Competitie}
Om gebruikers gemotiveerd te houden is competitie een uitstekende tool. Daarom hebben we 2 competitie-elementen toegevoegd.
\begin{description}
    \item[Challenges] Deze zijn snelheidsuitdagingen tegen vrienden. De snelste staat bovenaan!
    \item[Leaderboard] Deze wedstrijd is algemeen en globaal. De gene die de meeste exercises correct heeft opgelost, is de kampioen.
\end{description}
