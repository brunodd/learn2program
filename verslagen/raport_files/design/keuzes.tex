\subsubsection{Programmeertaal}
We zijn begonnen met het PHP framework \href{http://laravel.com/}{\emph{Laravel (5.0)}}.
Aangezien niemand van ons enige ervaring had met webdevelopment of webdesign was het een
enorme hulp om een soort template te hebben waar we op konden voortgaan. Een bijkomende reden
om Laravel te gebruiken is dat het een zeer uitgebreide en actieve community bevat, evenals veel en
duidelijke tutorials. \\
Laravel gebruikt MVC design, wat we dan ook gevolgd hebben. Voor alle grote klassen
werd een Controller aangemaakt. Deze Controller bevat de voornaamste php code. De resultaten die in de
Controller behaald worden, worden dan gebruikt om Views te cre\"{e}ren die de content geformatteerd renderen (als html code).

\subsubsection{Database communicatie}
Om met objecten te kunnen werken worden zogenaamde Models aangemaakt. Dit zijn php klassen die
gebruikt worden als container voor de data die via SQL queries worden opgevraagd.
Bovendien worden deze gebruikt om een zekere mate van beveiliging toe te voegen doordat
in deze models gespecifieerd kan worden welke data wel of niet kan aangepast worden. \\
SQL queries worden verzameld in een enkele file, en worden doorheen het programma gebruikt om te communiceren
met de database.

\subsubsection{Python interpreter}
Als python interpreter hebben we gekozen voor \href{http://www.skulpt.org/}{\emph{Skulpt}}.
Skulpt is een 'in-browser' implementatie van python. De voornaamste voordelen hiervan zijn dat
beveiliging veel minder belangrijk is, omdat het kwetsbare systeem voornamelijk de eigen computer
van de gebruiker is. Een tweede voordeel is dat de interpretatie van python code geen rekenkracht vergt van
de servers. Dit maakt dat het systeem voorbereid is voor gelijktijdig gebruik door een groot aantal gebruikers.
Een nadeel van dit systeem is dan weer dat Skulpt een implementatie is van Python, en dus niet hetzelfde is als de
werkelijke python interpreter. Hierdoor is skulpt niet hetzelfde als de officiele python interpreter. Na
afweging van voor- en nadelen hebben we besloten dat de voordelen zwaarder doorwegen. Voornamelijk omdat
de applicatie dient om te leren programmeren. De nadruk ligt dus op relatief eenvoudige problemen, waardoor
de meer gevorderde zaken die eventueel zouden ontbreken niet van toepassing zijn.

\subsubsection{Exercise flow-control}
\begin{description}
\item[Reeksen] Bij het maken van een reeks, kan een gebruiker slechts in een vaste volgorde de oefeningen oplossen. Op deze manier is er
een mate van controle over de volgorde van oplossen. Het is echter niet vereist dat een gebruiker de oefening correct oplost
om verder te kunnen gaan, een enkele poging is voldoende.
\item[Individuele oefeningen] Bij het oplossen van individuele oefeningen wordt een gelijkaardig systeem toegepast. Om hier een mate van controle te behouden,
krijgt een gebruiker slechts de oefeningen te zien die hij mag oplossen. Indien een gebruiker nog geen enkele oefening van een
willekeurige reeks gemaakt heeft, zal hij in de lijst van beschikbare oefeningen alleen de eerste oefening van die reeks te zien
krijgen.
\end{description}

\subsubsection{Score bepaling}
Om een zekere uniformiteit en objectiviteit te garanderen wordt iedere oefening binnen een reeks even zwaar gequoteerd. De score
die een gebruiker op een reeks behaald is afhankelijk van het percentage van oefeningen binnen die reeks die hij correct heeft opgelost.
Door moeilijke reeksen en makkelijke reeksen gelijk te quoteren, is het voor een beginner minder demotiverend om lage scores te halen
(vergeleken met zeer gevorderde vrienden bijvoorbeeld).
